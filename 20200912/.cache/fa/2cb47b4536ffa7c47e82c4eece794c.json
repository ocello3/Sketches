{"id":"../node_modules/standardized-audio-context/build/es2019/interfaces/base-audio-context.js","dependencies":[{"name":"/Users/daiki/Sketches/20200912/node_modules/standardized-audio-context/build/es2019/interfaces/base-audio-context.js.map","includedInParent":true,"mtime":499162500000},{"name":"/Users/daiki/Sketches/20200912/node_modules/standardized-audio-context/src/interfaces/base-audio-context.ts","includedInParent":true,"mtime":499162500000},{"name":"/Users/daiki/Sketches/20200912/package.json","includedInParent":true,"mtime":1600613796599},{"name":"/Users/daiki/Sketches/20200912/node_modules/standardized-audio-context/package.json","includedInParent":true,"mtime":1600612523678}],"generated":{"js":""},"sourceMaps":{"js":{"version":3,"file":"base-audio-context.js","sourceRoot":"","sources":["../../../src/interfaces/base-audio-context.ts"],"names":[],"mappings":"","sourcesContent":["import { TContext, TDecodeErrorCallback, TDecodeSuccessCallback } from '../types';\nimport { IAnalyserNode } from './analyser-node';\nimport { IAudioBuffer } from './audio-buffer';\nimport { IAudioBufferSourceNode } from './audio-buffer-source-node';\nimport { IAudioNode } from './audio-node';\nimport { IAudioWorklet } from './audio-worklet';\nimport { IBiquadFilterNode } from './biquad-filter-node';\nimport { IConstantSourceNode } from './constant-source-node';\nimport { IConvolverNode } from './convolver-node';\nimport { IDelayNode } from './delay-node';\nimport { IDynamicsCompressorNode } from './dynamics-compressor-node';\nimport { IGainNode } from './gain-node';\nimport { IIIRFilterNode } from './iir-filter-node';\nimport { IMinimalBaseAudioContext } from './minimal-base-audio-context';\nimport { IOscillatorNode } from './oscillator-node';\nimport { IPannerNode } from './panner-node';\nimport { IPeriodicWave } from './periodic-wave';\nimport { IPeriodicWaveConstraints } from './periodic-wave-constraints';\nimport { IStereoPannerNode } from './stereo-panner-node';\nimport { IWaveShaperNode } from './wave-shaper-node';\n\nexport interface IBaseAudioContext<T extends TContext> extends IMinimalBaseAudioContext<T> {\n    // The audioWorklet property is only available in a SecureContext.\n    readonly audioWorklet?: IAudioWorklet;\n\n    createAnalyser(): IAnalyserNode<T>;\n\n    createBiquadFilter(): IBiquadFilterNode<T>;\n\n    createBuffer(numberOfChannels: number, length: number, sampleRate: number): IAudioBuffer;\n\n    createBufferSource(): IAudioBufferSourceNode<T>;\n\n    createChannelMerger(numberOfInputs?: number): IAudioNode<T>;\n\n    createChannelSplitter(numberOfOutputs?: number): IAudioNode<T>;\n\n    createConstantSource(): IConstantSourceNode<T>;\n\n    createConvolver(): IConvolverNode<T>;\n\n    createDelay(maxDelayTime?: number): IDelayNode<T>;\n\n    createDynamicsCompressor(): IDynamicsCompressorNode<T>;\n\n    createGain(): IGainNode<T>;\n\n    createIIRFilter(feedforward: number[], feedback: number[]): IIIRFilterNode<T>;\n\n    createOscillator(): IOscillatorNode<T>;\n\n    createPanner(): IPannerNode<T>;\n\n    createPeriodicWave(real: number[], imag: number[], constraints?: Partial<IPeriodicWaveConstraints>): IPeriodicWave;\n\n    createStereoPanner(): IStereoPannerNode<T>;\n\n    createWaveShaper(): IWaveShaperNode<T>;\n\n    decodeAudioData(\n        audioData: ArrayBuffer,\n        successCallback?: TDecodeSuccessCallback,\n        errorCallback?: TDecodeErrorCallback\n    ): Promise<AudioBuffer>;\n}\n"]}},"error":null,"hash":"a5e5f1efc8aae63d007fb4d87bf7787c","cacheData":{"env":{}}}